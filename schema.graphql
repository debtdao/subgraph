# https://github.com/messari/subgraphs/blob/master/schema-generic.graphql
type Token @entity {
  # " Smart contract address of the token "
  id: ID!

  # " Name of the token, mirrored from the smart contract "
  name: String!
  # " Symbol of the token, mirrored from the smart contract "
  symbol: String!
  # " The number of decimal places this token uses, default to 18 "
  decimals: Int!
  # " Optional field to track the price of a token, mostly for caching purposes "
  lastPriceUSD: BigDecimal
  # " Optional field to track the block number of the last token price "
  lastPriceBlockNumber: BigInt
}

# LoC
type LineOfCredit @entity {
  id: ID!
  # LoC, Bullet, etc.
  type: String!
  # when line was deployed
  start: Int!
  # when ttl expires
  end: Int!
  # 
  status: String!

  # add global usd/interest value for easy dispaly on frontend cards? (also more accurate historical pricing)

  # modules
  escrow: Escrow @derivedFrom(field: "contract")
  spigot: SpigotController @derivedFrom(field: "contract")
  # 0x exchange address we trade against
  dex: Bytes!

  #stakeholders
  borrower: Borrower!
  oracle: Bytes!
  arbiter: Bytes!

  # `lines` not guaranteed to return in order of repayment queue like smart contract
  lines: [Credit!]! @derivedFrom(field: "contract")
  events: [LineEvent!]!  @derivedFrom(field: "contract")
}

type Credit @entity {
  id: ID!       # keccak(line,lender,token)
  contract: LineOfCredit!
  token: Token!
  lender: Lender!
  borrower: Borrower!
  # 0 indexed position in repayment queue
  # only has value if drawndown
  queue: Int
  
  deposit: BigInt!
  principal: BigInt!
  interestAccrued: BigInt!
  interestRepaid: BigInt!
  totalInterestEarned: BigInt! # lifetime gross revenue of lender on position
  # TODO remove usd vals, use Token price to calculate. Suffers same stale data issues as contracts
  principalUsd: BigDecimal!
  interestUsd: BigDecimal!
  

  # interest in bps charged on principal
  drawnRate: Int!
  # interest in bps charged on deposit less principal
  facilityRate: Int!
}

type Lender @entity {
  id: ID!
  credits: [Credit!] @derivedFrom(field: "lender")
}

type Borrower @entity {
  id: ID!
  debts: [LineOfCredit!] @derivedFrom(field: "borrower") # all contracts
  lines: [Credit!] @derivedFrom(field: "borrower") # all lines on all contracts
}

#  Line EVENTS 

# dont need to track in database, just need event to initialize data
# type DeployLineEvent  @entity {
#   id: ID!
#   block: BigInt!
#   timestamp: BigInt!

#   oracle: Bytes!
#   arbiter: Bytes!
#   bottower: Bytes!
# }


interface LineEvent {
  id: ID!                 # block-logIndex
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit! # could get from Credit but this makes it easier to traverse
  credit: Credit!
}

type UpdateStatusEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!  # the first line in payment queue at time of status update
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  status: Int!
}

type AddCreditEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal!
  drawnRate: BigInt!
  facilityRate: BigInt!
}

type ClosePositionEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!
}

type WithdrawProfitEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal!
}

type WithdrawDepositEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal!
}

type BorrowEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal!
}

type InterestAccruedEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal!
}

type RepayInterestEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal!
}

type RepayPrincipalEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal!
}


type LiquidateEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal! # not necessarily the amount received from executingliquidation 
  liquidator: Bytes!  # contract or arbiter responsible for executing liquidations

}

type DefaultEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  amount: BigInt!
  value: BigDecimal!
}

type SetRatesEvent implements LineEvent @entity {
  id: ID! # block-logIndex
  credit: Credit!
  block: BigInt!
  timestamp: BigInt!
  contract: LineOfCredit!

  drawnRate: Int!    # bps
  facilityRate: Int! # bps
}


# MODULES

# Spigot / Spigot Consumer

type SpigotController @entity {
  id: ID!                         # address
  owner: Bytes!
  contract: LineOfCredit          # should be `owner` if configured for collateral
  startTime: BigInt!              # timestamp when deployed

  operator: Bytes!
  treasury: Bytes!

  spigots: [Spigot!] @derivedFrom(field: "controller")
  events: [SpigotControllerEvent!] @derivedFrom(field: "controller")
}

interface SpigotControllerEvent {
  id: ID! # block-logIndex
  controller: SpigotController!
  block: BigInt!
  timestamp: BigInt!
}

type UpdateOwnerEvent implements SpigotControllerEvent @entity {
  id: ID! # block-logIndex
  controller: SpigotController!
  block: BigInt!
  timestamp: BigInt!

  oldOwner: Bytes!
  newOwner: Bytes!
}

type UpdateOperatorEvent implements SpigotControllerEvent @entity {
  id: ID! # block-logIndex
  controller: SpigotController!
  block: BigInt!
  timestamp: BigInt!

  oldOperator: Bytes!
  newOperator: Bytes!
}

type UpdateTreasuryEvent implements SpigotControllerEvent @entity {
  id: ID! # block-logIndex
  controller: SpigotController!
  block: BigInt!
  timestamp: BigInt!

  oldTreasury: Bytes!
  newTreasury: Bytes!
}

type WhitelistFunctionEvent implements SpigotControllerEvent @entity {
  id: ID! # block-logIndex
  controller: SpigotController!
  block: BigInt!
  timestamp: BigInt!

  func: Bytes!
  whitelisted: Boolean!
}

type ClaimEscrowEvent implements SpigotControllerEvent @entity {
  id: ID! # block-logIndex
  controller: SpigotController!
  block: BigInt!
  timestamp: BigInt!
  to: LineOfCredit!

  amount: BigInt! # amount of tokens sent to Owner from escrow
  value: BigDecimal!
}

# TODO rename Seting and Controlelr to Spigot
type Spigot @entity {
  id: ID!                       # spigot-revenueContract
  controller: SpigotController!
  token: Token!                 # token revenue is earned in
  contract: Bytes!              #revenue generating contract
  startTime: BigInt!            # time that spigot started

  active: Boolean!              # if contract is currently attached to spigot
  ownerSplit: Int!              # % of tokens escrowed for owner
  escrowed: BigInt!             # current amount of tokens available for owner to claim

  totalVolume: BigInt!          # total amount of tokens earned as revenue
  totalVolumeUsd: BigDecimal!    # usd value of total token volume
  
  events: [SpigotEvent!] @derivedFrom(field: "spigot")
}



interface SpigotEvent {
  id: ID! # block-logIndex
  spigot: Spigot!
  revenueToken: Token!
  block: BigInt!
  timestamp: BigInt!
}

type UpdateOwnerSplitEvent implements SpigotEvent @entity {
  id: ID! # block-logIndex
  spigot: Spigot!
  revenueToken: Token!
  block: BigInt!
  timestamp: BigInt!
  newSplit: Int!
}

type AddSpigotEvent implements SpigotEvent @entity {
  id: ID! # block-logIndex
  spigot: Spigot!
  revenueToken: Token!
  block: BigInt!
  timestamp: BigInt!
}

type RemoveSpigotEvent implements SpigotEvent @entity {
  id: ID! # block-logIndex
  spigot: Spigot!
  revenueToken: Token!
  block: BigInt!
  timestamp: BigInt!
}

type ClaimRevenueEvent implements SpigotEvent @entity {
  id: ID! # block-logIndex
  spigot: Spigot!
  block: BigInt!
  timestamp: BigInt!

  revenueToken: Token!
  escrowed: BigInt! 
  netIncome: BigInt! # amount of tokens sent to Treasury after Line cut escrowed
  value: BigDecimal!
}

# @dev only tracks revenue. does not track actual line repayment
type TradeRevenueEvent implements SpigotEvent @entity {
  id: ID! # block-logIndex
  spigot: Spigot!
  block: BigInt!
  timestamp: BigInt!

  revenueToken: Token!
  sold: BigInt! # amount of tokens about
  soldValue: BigDecimal! # usd value to 8 decimals

  debtToken: Token!
  bought: BigInt!
  boughtValue: BigDecimal! # usd value to 8 decimals
}

# Escrow

type Escrow @entity {
  id: ID! # address
  oracle: Bytes!
  contract: LineOfCredit!
  
  collateralValue: BigDecimal!
  cratio: BigDecimal!
  minCRatio: BigDecimal!

  deposits: [EscrowDeposit!]! @derivedFrom(field: "escrow")
}

type EscrowDeposit @entity {
  id: ID! # address-token
  escrow: Escrow!
  enabled: Boolean!
  token: Token!
  amount: BigInt!
  events: [EscrowEvent!]! @derivedFrom(field: "deposit")
}

interface EscrowEvent {
  id: ID! # block-logIndex
  deposit: EscrowDeposit!
  block: BigInt!
  timestamp: BigInt!
}

type EnableCollateralEvent implements EscrowEvent @entity {
  id: ID! # block-logIndex
  deposit: EscrowDeposit!
  block: BigInt!
  timestamp: BigInt!
}

type AddCollateralEvent implements EscrowEvent @entity {
  id: ID! # block-logIndex
  deposit: EscrowDeposit!
  block: BigInt!
  timestamp: BigInt!
  
  amount: BigInt!
  value: BigDecimal!
}

type RemoveCollateralEvent implements EscrowEvent @entity {
  id: ID! # block-logIndex
  deposit: EscrowDeposit!
  block: BigInt!
  timestamp: BigInt!

  amount: BigInt!
  value: BigDecimal!
}

# LiquidateEvent handled in LineOfCredit because more data available


#  Factory EVENTS 
interface DeployEvent {
  id: ID!
  timestamp: BigInt!
  block: BigInt!
  factory: Bytes!
  deployer: Bytes!
  address: Bytes!
}

type DeploySecuredLineEvent implements DeployEvent & LineEvent @entity {
  #DeployEvent
  id: ID!
  timestamp: BigInt!
  block: BigInt!
  factory: Bytes!
  deployer: Bytes!
  address: Bytes!

  # LineEvent conformity
  contract: LineOfCredit # same as address. Surfaces event in line logs
  credit: Credit! # always 0

  # event params
  escrow: Escrow!
  spigot: Spigot!

}

type DeploySpigotEvent implements DeployEvent & SpigotControllerEvent @entity {
  # DeployEvent
  id: ID!
  timestamp: BigInt!
  block: BigInt!
  factory: Bytes!
  deployer: Bytes!
  address: Bytes!

  # SpigotControllerEvent conformity
  controller: SpigotController!
  
  # event params
  owner: Bytes!
  operator: Bytes!
  treasury: Bytes!
}

type DeployEscrowEvent implements DeployEvent @entity {
  id: ID!
  timestamp: BigInt!
  block: BigInt!
  factory: Bytes!
  deployer: Bytes!
  address: Bytes!

  # event params
  minCRatio: BigInt!
}
